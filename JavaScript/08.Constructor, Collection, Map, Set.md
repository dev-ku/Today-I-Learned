# 📌 4일차 
- 2021.09.28(화)
- 강의 : 자바스크립트 35~38
  - 생성자 (Constructor)
  - Collection
  - Map
  - set
  
<br>

### 👉 생성자 (Constructor)
- 생성자 함수 : 유사한 객체를 다중으로 만들 때 사용되는 함수 (타 언어에서의 class)
- 일반적으로 생성자 함수의 첫 글자는 대문자로 시작한다
- 생성자 함수로 객체를 생성할 때에는 new 연산자를 사용한다 
- 생성자는 붕어빵 틀이고, 유사한 객체는 앙금이나 가격이 다른 붕어빵이라고 생각하자.
```javascript
function FishBread(flavor, price){
  this.flavor = flavor;
  this.price = price;
  this.base = "flour";
}

let bread = FishBread("test", 1200);
let bread1 = new FishBread("cream", 1200);
let bread2 = new FishBread("redbean", 1000);
let bread3 = new FishBread("milk", 1500);

console.log(bread);     // 
console.log(bread1);    // FishBread { flavor: 'cream', price: 1200, base: 'flour' }
console.log(bread2);    // FishBread { flavor: 'redbean', price: 1000, base: 'flour' }
console.log(bread3);    // FishBread { flavor: 'milk', price: 1500, base: 'flour' }
```
- 유사한 객체를 생성자 함수와 `new` 연산자를 사용해 빠르게 생성할 수 있다
- 객체를 생성할 때 `new` 연산자를 함께 사용하지 않으면 객체가 생성되지 않고 `undefined`를 반환한다 
```javascript
function User(name){
  console.log(new.target);
  this.name = name;
}

// not use new
let res1 = User("jjangu");        // undefined
console.log("res1 :", res1);      // res1 : undefined

// use new
let res2 = new User("yuri");      // [Function: User]
console.log("res2 :", res2);      // res2 : User { name: 'yuri' }
```
- 객체 내부적으로도 `new` 연산자와 함께 호출되었는지 확인하는 속성(property)이 존재한다
- `.new.target` 를 사용하면 `new`와 함께 호출되었는지 여부를 확인할 수 있다
- 객체 내부에서 `.new.target`의 반환값이 `undefined`이라면 `new` 연산자를 사용한 객체 생성이 아님을 알수있다
- `new`와 함께 객체를 생성한 경우에는 `.new.target`은 객체 생성에 사용된 `function`에 대해 반환한다
```javascript
// Boolean(undefined) -> false

function User(name){
  if(!new.target){
    return new User(name);
  }else{
    this.name = name;
  }
}
```
- `new.target`의 반환값에 대한 조건문을 두어 `new`를 사용하지 않은 상황을 대응할 수 있다
- `new`를 사용하지 않았다면 객체 내부에서 `new Object(value)`를 return해주어 `new` 연산자를 사용하도록 유도한다
- `new.target`의 반환값에 따른 대응을 통해 좀 더 유연한 생성자 함수를 만들수있다

<br>

### 👉 Collection
- `Collection` : 구조 또는 비구조화 형태로 프로그래밍 언어가 제공하는 값을 담을 수 있는 공간을 말한다 
- `Collection` 객체는 내부적으로 `Iterator를` 가지고 있다
- 자바스크립트에서 제공하는 `Collection`의 종류
  - `Indexed Collection` : index를 통해 각 element에 접근할 수 있는 `Collection` (예) `Array`, `Typed Array`
  - `keyed Collection ` : 특정 string, 자료형을 통해 접근할 수 있는 `Collection` (예) `Object`, `Map`, `Weak Map`, `Set`, `Weak Set`

<br>

### 👉 Map
- 다양한 자료형의 key를 허용하고, key-value 형태의 자료형을 저장할 수 있는 Collection 을 말한다
- Map은 Object보다 다양한 key의 사용을 허용한다
- 값을 추가하거나 삭제할 때에는 정해진 메서드를 사용한다
- 대표적인 속성(property) 및 메서드(method)
  - 생성자 : `new Map()`
  - 개수 확인 : `Map.size`
  - 요소 추가 : `Map.set(key,value)`
  - 요소 접근 : `Map.get(key)`
  - 요소 삭제 : `Map.delete(key)`
  - 전체 삭제 : `Map.clear()`
  - 요소 존재 여부 확인 : `Map.has(key)`
  - 그 밖의 메서드 : `Map.keys()`, `Map.values()`, `Map.entires()`
```javascript
let map = new Map();
  
map.set("name", "jjangu");        // string key
map.set(123, 456);                // number key
map.set(true, "bool");            // boolean key
```
- 다양한 자료형을 key로 사용할 수 있다 
```javascript
console.log(map);                 // Map(3) { 'name' => 'jjangu', 123 => 456, true => 'bool' }
console.log(map.get(123));        // 456
console.log(map.get("name"));     // jjangu
console.lgo(map.size);            // 3

map.clear();
console.log(map);                 // Map(0) { }
```
- 요소 추가 : `Map.set(key,value)`
- 요소 접근 : `Map.get(key)`
- 요소 삭제 : `Map.delete(key)`
- 전체 삭제 : `Map.clear()`
- 크기 확인 : `Map.size`
```javascript
map.set("name", "yuri").set(456, 123).set(false, "boolean");
console.log(map);
/*
Map(5) {
  'name' => 'yuri',
  123 => 456,
  true => 'bool',
  456 => 123,
  false => 'boolean'
} */
```
- `map.set` 호출 시 map이 반환되므로 체이닝(chaining)이 가능하다
- [참고] 체이닝(chaining) : 요소에 메서드를 연속적으로 사용할 수 있는데, 형태가 마치 체인이 엮인 모양과 같아 체이닝 기법이라고 말한다 
```javascript
```
- 
```javascript
```
- 
```javascript
```
- 
```javascript
```
- 

<br>

### 👉 set
```javascript
```

<br>
