# 실행 컨텍스트 vs Lexical 환경
렉시컬 환경을 공부하다보니, 실행 컨텍스트라는 개념과 어떤 차이가 있는건지 궁금해졌다. <br>
실행 컨텍스트를 복습하며 렉시컬 환경과의 차이점도 찾아보자.

<hr>

## 수정 및 추가 예정!
### 1. 실행 컨텍스트 생성 단계
### 2. 실행 컨텍스트 실행 단계
### 3. 클로저와 실행 컨텍스트
### 4. 함수 선언식 vs 함수 표현식

<hr>

<br>
<br>

## 🔥 [추가] 실행 컨텍스트와 Lexical 환경
- 실행컨텍스트의 동작 방식을 ES5.1 전후로 나누어 알아보자

<br>

### 🚀 ES5.1 이전 
- <a href = "https://github.com/dev-ku/Today-I-Learned/blob/main/javascript/11-2.LexicalEnviroment%20VS%20ExecutionContext(1).md#-es51-%EC%9D%B4%EC%A0%84--%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%86%8D%EC%84%B1">11-2.LexicalEnviroment VS ExecutionContext(1)</a>

<br>

### 🚀 ES5.1 이후 : 실행 컨텍스트의 컴포넌트
```javascript
실행컨텍스트 = {
    <LexicalEnvironment component>
    <VariableEnvironment component>
}
```
- ES5.1 이전의 실행 컨텍스트는 3가지 속성(스코프체인, 변수객체, thisValue)을 가졌다
- ES5.1 이후에서는 이전과 다르게 `LexicalEnvironment Component` 와 `VariableEnviroment Component` 로 구성된다
- ES5.1 이후의 실행 컨텍스트를 객체의 형태로 표현하면 위와 같다

<br>

### 실행 컨텍스트의 생성단계
- ES5.1 이후의 실행컨텍스트가 생성되는 단계를 알아보자
- 생성 단계에서 어떤 것들이 생성되는지에 대해 아는 것이 중요하다
    1. `LexicalEnvironment Component` : 어휘 환경 컴포넌트
        - 자바스크립트 엔진이 자바스크립트 코드를 실행하기위한 자원을 모아둔다
        - 함수 또는 블록의 유효범위안에 있는 식별자와 그 결과값이 저장된다
        - 자바스크립트 엔진은 유효범위안에 있는 변수 선언문이나 함수 선언문만을 저장한다
    2. `VariableEnviroment Component` : 변수 환경 컴포넌트
- `LexicalEnvironment Component`는 3가지 컴포넌트를 갖는다
    1. 환경레코드(Environment Recode) : 변수와 함수 선언이 저장되는 장소
        - ES5.1이전의 변수 객체와 비슷한 역할 
    2. 외부 환경 참조(Rerence to the outer environment)
        - 현재 실행 컨텍스트 외부의 `LexicalEnvironment`에 대한 참조를 말한다
        - JS엔진은 현재 실행 컨텍스트의 변수를 찾을 때 현재 `LexicalEnvironment`에 찾고자 하는 변수가 없다면
        - 외부 환경에 대한 참조를 통해 외부 환경까지 접근하여 찾고자하는 변수를 찾을 수 있다
    3. this binding
        - 전역 실행컨텍스트의 this가 참조하는 값은 전역 객체가 되고
        - 함수 실행컨텍스트의 this가 참조하는 값은 함수의 호출 방식에 따라 다르다 
-  `VariableEnviroment Component`는  `LexicalEnvironment Component`를 참조한다
    - 지금부터는 `VariableEnviroment Component`를 VE, `LexicalEnvironment Component`를 LE 라고 말한다
    - VE와 LE의 차이점이 뭘까? 변수에 대한 환경이라는건 비슷한것같은데 굳이 구분하는 이유가 뭘까
    - LE는 환경 레코드에 변수와 함수 선언을 저장하고 VE는 변수 환경 컴포넌트라고 하는데 차이점은?
        1. LE는 식별자에 대한 레퍼런스를 갖는다.
            - LE는 변수선언 및 함수선언문에 대한 식별자의 레퍼런스를 갖는다
            - 선언과 초기화가 함께되는 변수와 함수 표현식은 
        2. LE와 VE는 기본적으로 LE를 참조한다
            - VE는 LE를 참조하여 선언된 변수와 함수의 식별자를 파악한다
            - 초기화, 값 할당에 해당하는 코드를 만나면 VE에서는 LE의 변수를 참조하여 값을 초기화한다 
        3. VE는 코드 진행 상황에 따라서 참조 대상이 다르다 
            - 이 말은 계속 나오는데, 의미를 나름대로 해석해보면
            - ES5.1 이전에 실행 컨텍스트가 가지던 스코프 체인처럼,
            - 함수 실행 컨텍스트의 VE는 1차적으로 자기 자신의 LE를 참조한다
            - 자기 자신의 LE에 찾는 변수가 없다면, LE의 컴포넌트인 외부 환경 참조를 통해
            - 외부 환경, 즉 바로 상위의 실행 컨텍스트의 LE를 참조해 해당 변수를 찾을 것이다
            - 이러한 이유로 코드 진행 상황에 따라서 참조 대상이 다르다는 의미로 이해하자
    - 이번에는 변수 선언 방식을 통해 VE와 LE의 차이점을 생각해보자
        - JS엔진이 실행되고, 전역 실행 컨텍스트가 생성되고 실행컨텍스트는 LE와 VE를 갖는다
        - LE에는 변수의 선언이, VE에는 변수 값에 대한 초기화/할당이 진행된다
        - `var`를 사용하면 변수의 선언과 `undefined`로의 초기화가 동시에 진행된다
            - 이 경우는 LE에 변수가 선언되고, VE에 `undefined`로 초기화한다(추측)
        - `let`, `const`를 사용하면 변수의 선언과 초기화가 별도로 진행된다
            - LE만 선언된 변수의 이름, 즉 식별자의 레퍼런스를 갖는다 
        - 그리고 함수 표현식의 경우 선언과 초기화가 동시에 이루어진다
        - 그렇기 때문에 JS엔진이 실행되고 전역에서 함수를 만들기 위해
        - 함수 선언식을 사용했다면 LE에, 함수 표현식을 사용했다면 LE뿐만아니라 VE에도 함수에 대한 정보가 담긴다
- 지금은 실행 컨텍스트의 생성단계이며, 실행을 통해 값을 할당하고 초기화하는 코드를 만나야 
- LE를 참조하는 VE의 해당 변수에 값이 할당된다.
- 하지만 `var`와 함수 선언식같이 선언과 초기화의 단계가 함께 이루어지는 경우를 위해 생성단계에서부터 VE가 필요한 것 같다
- VE에 실질적으로 값이 할당되는 것은 실제로 실행 컨텍스트가 실행되는 단계에서 주로 이루어진다


<br>

### 실행 컨텍스트의 실행단계
- 실행 단계에서는 모든 변수에 대한 값의 할당이 완료되고 코드가 최종적으로 실행된다




<br>
<br>

## 🔥 [결론] 실행 컨텍스트의 컴포넌트 중 하나인 렉시컬 환경

- 





<hr>

### [참고]
https://oyg0420.tistory.com/entry/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8  `추천👍`


