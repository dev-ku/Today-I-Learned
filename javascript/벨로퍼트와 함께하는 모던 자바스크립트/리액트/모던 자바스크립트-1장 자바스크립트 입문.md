# 벨로퍼트와 함께하는 모던 자바스크립트
- 2022/04/04(월)
- 벨로퍼트와 함께하는 모던 자바스크립트: https://learnjs.vlpt.us/

<br>


## 1장 자바스크립트 입문
- 리액트 공부에 들어가기에 앞서서 `벨로퍼트와 함께하는 모던 자바스크립트` 를 통해 자바스크립트 기초를 한번 훑는다
- 미숙한 부분은 해당 md파일에 작성하며 복습한다

<br>

### 💬 null vs undefined
- `null`: 없음
- `undefined`: 아직 값이 설정되지 않음 

<br>

### 💬 템플릿 리터럴(Template Literal)
```jsx
function hello(name) {
  console.log(`Hello, ${name}!`);
}
hello('velopert');
```
- 템플릿 리터럴은 내장된 표현식을 허용하는 문자열 리터럴이다
- 템플릿 리터럴은 작은따옴표(')나 큰따옴표(") 대신 백틱(`)(grave accent)을 사용한다 
- 템플릿 리터럴 내부에서의 개행은 그대로 출력된다
- [참고] https://eblee-repo.tistory.com/38

<br>

### 💬 화살표 함수 (=>)
```jsx
const add = (a, b) => {
  return a + b;
};

console.log(add(1, 2));
```
- function 키워드 대신에 `=>` 문자를 사용해서 함수를 구현한다
- 화살표의 좌측에는 함수의 파라미터, 화살표의 우측에는 실행문을 작성한다
- 화살표 함수와 일반 function 으로 만든 함수는 서로 가르키는 `this`가 서로 다르다는 차이점이 있다
- 화살표 함수의 제약
    - 무조건 익명함수로만 사용할 수 있다
    - 메소드나 생성자 함수로 사용할 수 없다

<br>

### 💬 this 바인딩
- 자바스크립트의 `this`는 상황에 따라 다르게 바인딩된다
    - 전역 공간의 `this`: 전역 객체
    - 메소드 호출 시 메소드 내부의 `this`: 해당 메소드를 호출한 객체
    - 함수 호출 시 함수 내부의 `this`: 지정되지 않는다 → 스코프 체인에 의해 `this`는 전역 객체를 의미하게 된다
- 이는 자바스크립트는 정적 스코프(렉시컬 스코프)를 따르기 때문이다
    - 함수의 선언 위치에 따라 상위스코프를 결정하는 방식
- 이러한 방식을 깨고, 화살표 함수는 호출위치에 따라 상위스코프를 결정하는 동적 스코프를 따른다
- 그렇기때문에 화살표함수와 일반 function으로 만든 함수는 `this`가 서로 다르다

<br>

```javascript
const student = {
    name: 'jjangu',
    func1: function() {
        console.log(this.name);         // jjangu
        const func2 = function() {      
            console.log(this);          // <ref *1> Object [global] { ... }
            console.log(this.name);     // undefined
        }
        func2();
    }
};
student.func1();
```
- `function` 키워드를 사용해 선언한 함수 `func1`과 `func2`는 선언된 위치를 토대로 상위 스코프를 결정한다
    - `func1`이 선언된 위치를 토대로 바로 상위 스코프인 `student`가 `this`로 바인딩된다
    - `func2`은 함수의 내부에 선언되었으므로, `this`가 지정되지 않는다. 그렇기 때문에 `this`는 스코프체인에 의해 결국 전역 객체로 바인딩된다
- `func1`의 `this.name`
    - `this`: student
    - `this.name` == `student.name` 이므로, `student`의 `name`변수를 가져와 출력한다
- `func2`의 `this.name`
    - `this`: 전역 객체(global object)
    - 전역 객체에는 `name`이라는 이름을 갖는 변수가 없으므로, `undefined`가 출력된다

<br>

```javascript
const student = {
    name: 'jjangu',
    func1: function() {
        console.log(this.name);         // jjangu
        const func2 = () => {
            console.log(this);          // { name: 'jjangu', func1: [Function: func1] }
            console.log(this.name);     // jjangu
        }
        func2(); // 호출 위치
    }
};
student.func1(); 
```
- 화살표 함수를 사용한 경우, `this`는 함수의 호출 위치에 따라 결정되는 동적 스코프를 따른다
- 화살표 함수인 `func2`는 호출 위치에 따라 상위 스코프가 결정되므로, `this`는 `student`를 가르키게 된다

<br>

### 💬 구조 분해 할당
```javascript
const student = {
    name: "jjangu",
    age: "5",
    address: "떡잎마을",
    className: "해바라기반"
}

const { name, age, address, className } = student;
console.log(`name: ${name}`);               // name: jjangu
console.log(`age: ${age}`);                 // age: 5
console.log(`address: ${address}`);         // address: 떡잎마을
console.log(`className: ${className}`);     // className: 해바라기반
```
- 객체 구조 분해 할당을 할 때에 속성명과 할당할 변수명을 동일하게 사용할 필요는 없다
- 객체 구조 분해 할당 시에는 `{ }` 를 사용하고, 배열을 구조 분해 할당할 때에는 `[ ]`를 사용한다 

<br>

### 💬 Getter 함수와 Setter 함수(New)


<br>

### for..of / for...in
```javascript
let numbers = [10, 20, 30, 40, 50];
for (let n of numbers) {
    console.log(n);
}
// 10 20 30 40 50
```
```javascript
const student = {
    name: 'jjangu',
    age: 5,
    className: '해바라기반'
};

for (let key in student) {
  console.log(`${key}: ${student[key]}`);
}

// name: jjangu
// age: 5
// className: 해바라기반
``` 

<br>

### 💬 

<br>

### 💬 

<br>

### 💬 

<br>

### 💬 