## 화살표 함수(Arrow Function Expression)
- `Array.from()` 메서드를 쓸 때 화살표함수를 많이 사용하길래, 겸사겸사 다시 한번 정리한다

<hr>
<br>

### 화살표 함수(Arrow Function Expression)
```jsx
var func = function ( x,  y ){
    return x + y;
}

var arrowFunc = ( x, y ) => x + y;

console.log(func(1,2));             // 3
console.log(arrowFunc(1,2));     // 3
```
- 화살표 함수는 전통적인 함수 표현에 대한 간편한 대안책이다
- `function` 키워드 없이, `=>` 를 사용해 정의한다

```jsx
// 매개 변수 지정
var test1 = ( ) => { console.log("Test") }      // 매개 변수가 없는 경우
var test2 = x => { console.log(x) }             // 매개 변수가 하나인 경우 소괄호 생략 가능
var test3 = (x, y) => { console.log(x, y) }     // 매개 변수가 여러 개인 경우 소괄호 *필수* 

test1();                        // Test
test2("hi");                   // hi
test3("hello", "world");    // hello world
```
- 화살표 함수에서 매개 변수를 지정할 때에는
    - 매개 변수 0개 : 소괄호를 작성해주어, 매개 변수가 필요없음을 명시한다
    - 매개 변수 1개 : 소괄호 생략 가능
    - 매개 변수 n개 : 소괄호 필수

```jsx
// 실행문 지정
var test1 = x => { return x * 2 }   // 실행문을 { } 안에 작성
var test2 = x => x * 2               // 실행문이 단 한줄의 구문이라면, 중괄호, return 생략 가능 
var test3 = x => ( {input: x} )      // 객체 반환 시, 소괄호로 감싸준다

test1(10);    // 20   
test2(10);    // 20
test3(10);    // { input: 10 }
``` 
- 화살표 함수에서의 실행문은 
    - 일반적으로 { } 안에 작성한다
    - single line function의 경우, {중괄호} 와 `return` 을 생략할 수 있다
        - 중괄호만 생략하고, `return` 을 남겨두면 에러 발생
    - multi line function의 경우, {중괄호} 와 `return` 을 생략할 수 없다
    - 만약 `return` 하고자 하는 값이 객체라면, 반드시 소괄호로 감싸준다

<br>
<br>

### 화살표 함수와 function 키워드를 사용했을 때의 차이는 뭘까?
- 단순히 문법의 차이라면 왜 화살표 함수를 사용해야할까?
- `function` 키워드를 사용한 함수와, 화살표 함수의 큰 차이점은 `this`에 있다. 서로 가리키는 `this`가 다르다
- 화살표 함수가 나오기 전에는 어떻게 함수가 호출되었는가에 따라 `this`를 정의했다.
- 화살표 함수에는 자기 자신이 가지는 `this`가 존재하지 않는다
- 대신, 화살표 함수를 둘러싸는 렉시컬 스코프의 `this`를 그대로 사용한다

#### 일반 함수의 `this`
```jsx
function Student() {
    this.name = "짱구";
    return {
        name: "유리",
        // 일반 함수의 this : 객체 내부에서의 this이므로, 객체 자기 자신을 의미
        print: function(){
            console.log(this.name + "입니다");
        } 
    }
}

const student = new Student();
student.print();    // 유리입니다
```
- 자바스크립트는 함수 호출 방식에 의해 `this`에 바인딩될 객체가 동적으로 결정된다
    - 생성자 함수와 객체 메서드의 `this` = 객체 자기 자신
    - 내부 함수, 콜백 함수 등 에서의 `this` = 전역 객체(window)
    - 혹은 `call()`, `apply()`, `bind()`를 사용해 직접 설정

#### 화살표 함수의 `this`
```jsx
function Student() {
    this.name = "짱구";
    return {
        name: "유리",
        // 화살표 함수의 this : 상위 스코프인 생성자 함수 스코프를 의미
        print: () => {
            console.log(this.name + "입니다");
        } 
    }
}

const student = new Student();
student.print();    // 짱구입니다
```
- 화살표 함수는 함수를 선언할 때, `this`에 바인딩할 객체가 정적으로 결정된다 
- 동적으로 결정되는 일반 함수와 달리, 화살표 함수의 `this`는 언제나 상위 스코프의 `this`를 가리킨다

<br>
<br>

### 화살표 함수에 없는 것들
1. `this`
    - 일반적인 함수와 달리, 화살표 함수는 호출되며 생성된 실행 콘텍스트에서 `thisBinding` 정보를 만들지 않는다
    - 현재 스코프에 `this` 가 정의되어 있지 않으므로, 스코프 체인을 타고 돌라가 가장 가까운 상위 스코프의 `this`를 참조한다
2. protoType
    - 자바스크립트에서는 
    - 화살표 함수는 `protoType`이 존재하지 않는다
    - 그렇기 때문에, `new`를 사용한 호출이 불가능하며, 자기 자신의 인스턴스 객체를 만들 수 없다
    - 즉, 생성자 함수의 역할을 할 수 없다

<br>
<hr>

## [참고]
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/Arrow_functions `📎MDN`
https://whales.tistory.com/37 `기본 사용방법 정리`
https://velog.io/@raram2/화살표-함수를-남용하면-안되는-이유
